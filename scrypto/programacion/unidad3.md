# Escribimos nuestro primer Componente

::: warning
- Esta unidad estÃ¡ actualizada para Scrypto version 0.4 o mayor -> [Instrucciones actualizaciÃ³n](/scrypto/instalacion/actualizacion.md)
:::

::: tip ðŸ“º
- [Soon Video DemostraciÃ³n]()
:::

Las fases para resolver un problema con una computadora suelen ser los siguientes, en el mundo de la programaciÃ³n:

- AnÃ¡lisis del problema
- DiseÃ±o del algoritmo
- CodificaciÃ³n
- CompilaciÃ³n y ejecuciÃ³n
- VerificaciÃ³n
- DepuraciÃ³n
- DocumentaciÃ³n
- Mantenimiento

(*Nota: no siempre se siguen estos pasos*)

### AnÃ¡lisis del problema
**Problema**: Estamos trabajando para una 'Aseguradora' que nos pide que implementemos la temperatura de cierta ciudad a la red de Radix, con el fin de que otros contratos inteligentes puedan tener el dato (on-chain) para ejecutar pÃ³lizas de seguros. Debemos poder modificar la temperatura con el fin de tener actualizado el dato.

**AnÃ¡lisis**: 
Si te diste cuenta, la 'Aseguradora' nos esta pidiendo que creemos un mecanismo para introducir datos externos a la red de Radix (OrÃ¡culo). Como sabrÃ¡s las redes DLT no conocen lo que sucede fuera de ellas, y la manera para introducir datos externos a una red DLT es a travÃ©s de *transacciones*. 
::: tip
- Las redes DLT son Deterministas, que es indispensable para que los nodos lleguen a un consenso. 
:::
**DivisiÃ³n del problema:**
- Debemos crear un componente que guarde un dato de temperatura, nosotros sabemos que ese dato debe ser un *decimal* ya que las temperaturas contienen decimales.
- Debemos crear una mÃ©todo que permita leer el dato.
- Debemos crear un mÃ©todo que permita cambiar el dato.

Con esto hemos convertido un problema en diferentes sub-problemas mas pequeÃ±os, recogiendo todas las necesidades actuales. 

::: tip Muy importante:
- Como programadores debemos ceÃ±irnos a lo que se nos ha solicitado, no inventemos ni agreguemos nuevas funcionalidades. 
:::

### DiseÃ±o del algoritmo

En este caso vamos a crear 3 algoritmos, uno para cada uno de los tres procesos bÃ¡sicos que nos han pedido. Para ello hoy utilizaremos el *diagramas de flujo*, es algo muy bÃ¡sico pero Ãºtil cuando empezamos a programar, en este caso los diagramas serÃ¡n muy sencillos pero en otros casos mÃ¡s adelante pueden sernos muy Ãºtiles para clarificar las ideas. (*Nota: En contenido extra al final de esta unidad tendrÃ¡s mas informaciÃ³n sobre diseÃ±o de algoritmos*)

![diagrama](/diagrama1.png)

Ya hablaremos mÃ¡s sobre **algoritmos** y su diseÃ±o, pero de momento quÃ©date con que en el diagrama *Crear Componente* se lee de la siguiente manera: Inicio -> Introducimos temperatura -> Procesamos la funciÃ³n *new* -> Finalizamos

Â¿SabrÃ­as leer los dos siguientes diagramas? Â¡Prueba!  

### CodificaciÃ³n

Primero vamos a crear el *Package*, recuerda que lo haremos desde la carpeta 'radixdlt-scrypto' Â¡eso ya sabes hacerlo!ðŸ¤ª:  

*(Nota: vamos a asignar el nombre 'tiempo' pero tu puedes optar por cualquier otro)* 
```
scrypto new-package tiempo
```
Seguidamente vamos a entrar en la carpeta que se crea con el nombre *tiempo* recuerda, lo hacemos con el comando *cd*
```
C:\Users\<tu_usuario>\radixdlt-scrypto> cd tiempo
```

Abrimos el archivo *lib.rs* que estÃ¡ dentro de la carpeta *src* con el Visual Studio Code, una vez abierto limpiamos el blueprint del cÃ³digo ejemplo para dejarlo de la siguiente manera:
```rust
use scrypto::prelude::*;

blueprint! {
    struct Hello {
    }
    impl Hello {
        pub fn instantiate_hello() -> ComponentAddress {
            Self {
            }
            .instantiate()
            .globalize()
        }

        pub fn free_token(&mut self) {
           
        }
    }
}
```
Como ves, hemos limpiado el blueprint del cÃ³digo que trae como ejemplo, esto es algo que de momento haremos siempre al empezar un nuevo *Package*.  

::: danger Recuerda
- Los Blueprint constan de dos partes principales: **struct** e **impl**
- En *struct* declararemos los recursos o datos que contendrÃ¡ el componente
- En *impl* crearemos las funciones y mÃ©todos necesarios para ejecutar las acciones requeridas, que podrÃ¡n modificar o no el estado del componente que se encuentra en la *estructura* (struct).
:::

Seguidamente vamos a cambiar el nombre del *blueprint*, quitaremos el **Hello** y lo cambiaremos por **Temperatura** tanto en la estructura como en la implementaciÃ³n:

```rust
blueprint! {
    struct Temperatura {
        .
        .
    }
    impl Temperatura {
        .
        .
    }
}
```
::: tip
- Ojo: que los nombres de las struct deben comenzar con MayÃºsculas. De momento quÃ©date con eso, ya te explicare mÃ¡s.
:::

Vamos a empezar a codificar el primer algoritmo **'Crear componente'**, recuerda:
- Debemos crear un componente que guarde un dato de temperatura, nosotros sabemos que ese dato ser un *decimal* ya que las temperaturas contienen decimales.

Esto quiere decir que tenemos que declarar un dato dentro del componente que guarde una temperatura (temp) que es un dato de tipo decimal:
```rust
struct Temperatura {
       temp: Decimal
    }
```

Ahora hemos de crear la funciÃ³n que instancia el componente, por convenciÃ³n vamos a llamar a esa funciÃ³n *instantiate_temperatura*, que suele ser la suma de *instanciate y el nombre del blueprint*.

```rust
pub fn instantiate_temperatura(temp_inicial: Decimal) -> ComponentAddress {
            Self {
               temp: temp_inicial,
            }
            .instantiate()
            .globalize()
        }
```

Si te percataste, la funciÃ³n *instantiate_temperatura* tiene un parÃ¡metro de entrada de tipo *decimal* (que guardamos dentro de la variable: temp_inicial) y uno de salida de tipo *ComponentAddress*. Seguidamente dentro de *Self* (el cual referencia a los recursos que hemos declarado en la *struct*) pasamos el dato que hemos dado por entrada en la funciÃ³n *instantiate_temperatura* a el recurso permanente que se guarda dentro del componente de tipo coincidente *decimal* (temp). Finalmente instanciamos el blueprint con la expresiÃ³n **.instanciate() y .globalize()** *(Nota: recuerda que como devuelve un valor no termina con punto y coma)*.

::: tip
- **.globalize()**: asigna una direcciÃ³n para que las personas puedan acceder al componente. Dicha direcciÃ³n se devuelve despuÃ©s a travÃ©s del tipo *ComponentAddress*.
:::

Con esto habrÃ­amos codificado el primer algoritmo, en este caso una funciÃ³n 'constructora' que por convencionalismos llamaremos en este caso *instantiate_temperatura* y que es con la que daremos *vida* a nuestro *blueprint*. Una vez dicho esto, vayamos con el segundo algoritmo: **'Leer el Dato'**.

Para ello vamos a crear un mÃ©todo, recuerda que bÃ¡sicamente un **mÃ©todo** es una *funciÃ³n* que estÃ¡ ligada a una estructura de datos (struct) y hace referencia a esta a travÃ©s de **self**. (*Nota: mÃ¡s adelante hablaremos de la habilidad que en Rust se denominada â€˜sintaxis de llamada a mÃ©todosâ€™*)

Estos mÃ©todos van a permitirnos ejecutar acciones dentro del *Componente*. Hemos dicho que un mÃ©todo es una funciÃ³n pues que vamos a escribir dentro del cuerpo de *impl*:

```rust
pub fn leer_temp(&self) {
}
```

Ya sabes que una funciÃ³n se declara con la partÃ­cula *fn* en este caso esta precedida de la partÃ­cula *pub* que hace referencia a que es una mÃ©todo *pÃºblico*. Dentro de los parÃ©ntesis del nombre de la funciÃ³n, en este caso *leer_temp*, estamos pasando una referencia (&) a si mismo (self), y con esto ya tendrÃ­amos un mÃ©todo codificado.

Â¿Que dice nuestro algoritmo que debe hacer esta mÃ©todo? Devolver el mensaje: "La temperatura es: {temperatura} grados." vamos a codificarlo:

```rust
pub fn leer_temp(&self) {
    info!("La temperatura es: {} grados.", self.temp);
}
```
Ya te habrÃ¡s percatado de que dentro de los {} corchetes se pintarÃ¡ por pantalla, junto al mensaje, el dato que se encuentra alojado en la estructura de nuestro Componente con el nombre *temp*. 

Nuestro cÃ³digo va quedando de la la siguiente manera, solo para que no pierdas la perspectiva:

```rust
blueprint! {
    struct Temperatura {
        temp: Decimal
    }
    impl Temperatura {
        pub fn instantiate_temperatura(temp_inicial: Decimal) -> ComponentAddress {
            Self {
               temp: temp_inicial,
            }
            .instantiate()
            .globalize()
        }

        pub fn leer_temp(&self) {
            info!("La temperatura es: {} grados.", self.temp);
        }
    }
}
```

Sigamos... ahora codificando el tercer algoritmo: **'Cambiar Temperatura'**, para ello nuevamente vamos a crear un mÃ©todo, Â¡ya sabemos hacerlo ðŸ˜Ž!, pero en este caso la referencia (&) a si mismo (self) tiene que ser mutable (mut), es decir que permita modificarse, para poder cambiar el dato que guarda el *Componente* dentro de la estructura. QuedarÃ­a de la siguiente manera:

```rust
pub fn cambiar_temp(&mut self)  {
}
```
Este tercer algoritmo nos pide que podamos modificar la temperatura, para ello hemos de permitir introducir un nuevo dato, esto lo logramos pasando un nuevo argumento a traves del mÃ©todo, recuerda que el dato es una temperatura que hemos declarado como tipo *Decimal* y por tanto, para que haya una concordancia de tipos, el dato que hemos de entrar deberÃ­a ser tambiÃ©n *Decimal*, quedarÃ­a algo asÃ­:

```rust
pub fn cambiar_temp(&mut self, nueva_temp: Decimal)  {
}
```
Finalmente guardamos el dato en la *estructura* dentro de la variable *temp* de la siguiente manera:

```rust
pub fn cambiar_temp(&mut self, nueva_temp: Decimal)  {
    self.temp = nueva_temp;
}
```

El operador igual (=) permite asignar valor y recuerda qwe esto lo podemos lograr gracias a que hemos declarado como mutable (mut) la referencia (&) a la estructura (self).

Con esto hemos codificado los tres algoritmos que nos pedÃ­an en las especificaciones iniciales del problema, quedando el cÃ³digo de la siguiente manera y terminando esta fase:

```rust
use scrypto::prelude::*;

blueprint! {
    struct Temperatura {
        temp: Decimal
    }
    impl Temperatura {
        pub fn instantiate_temperatura(temp_inicial: Decimal) -> ComponentAddress {
            Self {
               temp: temp_inicial,
            }
            .instantiate()
            .globalize()
        }

        pub fn leer_temp(&self) {
            info!("La temperatura es: {} grados.", self.temp);
        }

        pub fn cambiar_temp(&mut self, nueva_temp: Decimal)  {
            self.temp = nueva_temp;
        }
    }
}
```

### CompilaciÃ³n y ejecuciÃ³n

Una vez superada la fase de *CodificaciÃ³n* pasamos a compilar y ejecutar:

::: tip
- Antes de nada vamos a limpiar nuestro *simulador* para poder compilar y ejecutar sin rastros anteriores con el siguiente comando de resim:
```
resim reset
```
:::

Compilar es sencillo, en nuestro caso no solo compila sino que tambiÃ©n integra en la red el *Package* asignÃ¡ndole una direcciÃ³n que guaramos dentro de una variable se sistema:

```
resim publish .
```

Seguidamente guardamos la direcciÃ³n del Package asignada (recuerda que en linux usamos *Export*):

```
set package <direcciÃ³n del package>
```
::: tip
En Linux y MacOs utilizaremos *export key=value* ejemplo:
```
export package=<direcciÃ³n del package>
```
:::

Creamos una nueva cuenta, que al ser la inicial quedara como la 'por defecto':

```
resim new-account
```
Guardamos nuestra direcciÃ³n en una variable de sistema:
```
set acct <direcciÃ³n de la nueva cuenta>
```

Ahora vamos a ejecutar la funciÃ³n 'constructora' *new* que **instancia** nuestro blueprint y lo convierte en un **Componente**, recuerda que hemos de pasa como argumento la temperatura inicial en este caso 20.5, y lo hacemos de la siguiente manera:
```rust 
resim call-function $package Temperatura instantiate_hello 20.5
```

Si todo ha salido bien... Ahora guardaremos en una variable de sistema la direcciÃ³n del componente:

```
set component <direcciÃ³n del componente>
```
::: tip
- Podemos ver el contenido del componente y verificar el dato de temperatura que hemos pasado como argumento
```
resim show $component
/* Resultado algo parecido a esto:
State: Struct { 20.5 }
*/
```
:::

Pasemos a comprobar el funcionamiento del mÃ©todo *leer_temp*:

```rust
resim call-method $component leer_temp
```
Si todo fue correcto, resultado ha de ser algo parecido a esto:

```
Logs: 1
â””â”€ [INFO ] La temperatura es: 20.5 grados.
```
Ahora le toca el turno a el mÃ©todo *cambiar_temp*, en este caso ademÃ¡s vamos a pasar la nueva temperatura:

Valor positivo:
```rust
resim call-method $component cambiar_temp 25
```

Valor negativo:
```rust
resim call-method $component cambiar_temp -- -5.2
// tenemos que poner delante del dato negativo dos guiones, 
// recuerda que los decimales se escriben con puntos y no con comas.
```


Si todo salio bien podemos comprobarlo volviendo a ejecutar por ejemplo el mÃ©todo *leer_dato*. Â¡Ya sabes como hacerlo!

### VerificaciÃ³n y DepuraciÃ³n

En este caso con la propia ejecuciÃ³n ya hemos verificado la correcta ejecuciÃ³n del *Componente* y ademÃ¡s hemos depurado, si hubiera sido necesario habrÃ­amos subsanando los errores producidos en la codificaciÃ³n. En algunos casos al codificar nos podemos percatar de que hayamos cometido errores en las fases de anÃ¡lisis y diseÃ±o, ahora estarÃ­amos en el momento de volver a estas fases para corregir los errores y volver a codificar, compilar, ejecutar y verificar. 

![verificacion](/verificacion.png)

*Nota: MÃ¡s adelante seguiremos explicando como en esta fase podemos implementar test (unitarios, funcionales, punta a punta, etc..) para verificar y depurar nuestros Blueprints.*

### DocumentaciÃ³n y Mantenimiento

Finalmente quedarÃ­a la fase de DocumentaciÃ³n donde deberÃ­amos describir los pasos dados en el proceso de resoluciÃ³n del problema y ejecuciÃ³n del programa. En la programaciÃ³n profesional existen diversos documentos que hay entregar, en este caso vamos simplemente a comentar nuestro cÃ³digo. 

::: tip  En Rust para comentar:
- **//** Comentario de una sola lÃ­nea
- /* ... */ Comentario multilinea 
- **///** Genera documentaciÃ³n de biblioteca para el siguiente elemento.
- **//!** Genera documentaciÃ³n de biblioteca para el elemento adjunto.
:::

Algo sencillo para nuestro blueprint seria asÃ­, los comentarios pueden ser algo subjetivos, normalmente los equipos de programaciÃ³n tienen unas normas y estilo claros, a la hora de codificar y documentar, para que todo el mundo se entienda:

```rust
use scrypto::prelude::*;

blueprint! {
    struct Temperatura {
        // Define un dato de tipo decimal para guardar la temperatura que luego utilizaremos en el componente.
        temp: Decimal
    }
    impl Temperatura {
        // Esta funciÃ³n despliega el componente, hay que pasar como argumento un decimal
        pub fn instantiate_temperatura(temp_inicial: Decimal) -> ComponentAddress  {
            // Instanciamos el componente Temperatura y poblamos el dato 'temp' con una temperatura inicial 
            Self {
               temp: temp_inicial,
            }
            .instantiate()
            .globalize()
        }
        // Este mÃ©todo devuelve un mensaje con la temperatura guardada en el dato 'temp'
        pub fn leer_temp(&self) {
            info!("La temperatura es: {} grados.", self.temp);
        }
        // Este mÃ©todo cambia el dato 'temp', se debe pasar un dato de tipo decimal
        pub fn cambiar_temp(&mut self, nueva_temp: Decimal)  {
            self.temp = nueva_temp;
        }
    }
}
```
El mantenimiento consta de: actualizaciÃ³n de los cambios/mejoras planteados y correcciÃ³n de posibles nuevos errores.

Enhorabuena... ya has podido escribir y ejecutar tu primer componente. SiÃ©ntete muy muy muy orgulloso.  En las prÃ³ximas lecciones ampliaremos el ejemplo y eso serÃ­a parte, en principio, parte del mantenimiento . DÃ©janos tus sugerencias!!!

::: warning Importante:
- Soy muy consciente de que hay muchas que no has entendido, Â¡TRANQUILO!, no te rindas, las entenderÃ¡s... ðŸ˜‰
:::

### Contenido extra
- [DiseÃ±o de algoritmos en la programaciÃ³n de computadoras](https://www.monografias.com/trabajos94/diseno-algoritmos-programacion-computadoras/diseno-algoritmos-programacion-computadoras.shtml)
- [Herramienta para dibujo de diagramas de flujos](https://lucid.app/)
- [MetodologÃ­a para la ConstrucciÃ³n de Programas, slide sencillas](https://slideplayer.es/slide/2269458/)